import { toast } from '@/components/ui/use-toast';
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

// generated by shadcn
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
export const isImage = (url: string) => {
  const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp'];
  return imageExtensions.some((extension) =>
    url.toLowerCase().endsWith(extension),
  );
};

export function isVideo(url: string): boolean {
  const videoExtensions = ['.mp4', '.webm', '.ogg'];
  const videoMimeTypes = ['video/mp4', 'video/webm', 'video/ogg'];
  return (
    videoExtensions.some((ext) => url.endsWith(ext)) ||
    videoMimeTypes.some((type) => url.includes(type))
  );
}
// created by chatgpt
export function isBase64Image(imageData: string) {
  const base64Regex = /^data:image\/(png|jpe?g|gif|webp);base64,/;
  return base64Regex.test(imageData);
}
export function throttle<T extends (...args: any[]) => void>(
  func: T,
  limit: number,
): (...args: Parameters<T>) => void {
  let lastFunc: NodeJS.Timeout | null = null;
  let lastRan: number | null = null;

  return function (this: unknown, ...args: Parameters<T>) {
    const context = this;
    const now = Date.now();

    if (!lastRan || now - lastRan >= limit) {
      func.apply(context, args);
      lastRan = now;
    } else {
      if (lastFunc) {
        clearTimeout(lastFunc);
      }
      lastFunc = setTimeout(
        () => {
          if (Date.now() - lastRan! >= limit) {
            func.apply(context, args);
            lastRan = Date.now();
          }
        },
        limit - (now - lastRan),
      );
    }
  };
}
export const copyLink = (url: string) => {
  navigator.clipboard
    .writeText(url)
    .then(() => {
      toast({
        title: 'Link copied to clipboard!',
      });
    })
    .catch((error) => {
      alert('Failed to copy link: ' + error);
    });
};
// created by chatgpt
export function formatDateString(dateString: string) {
  const options: Intl.DateTimeFormatOptions = {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  };

  const date = new Date(dateString);
  const formattedDate = date.toLocaleDateString(undefined, options);

  const time = date.toLocaleTimeString([], {
    hour: 'numeric',
    minute: '2-digit',
  });

  return `${time} - ${formattedDate}`;
}

// created by chatgpt
export function formatThreadCount(count: number): string {
  if (count === 0) {
    return 'No Threads';
  } else {
    const threadCount = count.toString().padStart(2, '0');
    const threadWord = count === 1 ? 'Thread' : 'Threads';
    return `${threadCount} ${threadWord}`;
  }
}

// Hàm mã hóa với XOR Cipher
export function encrypt(text: string, key: string) {
  let encryptedText = '';
  // Lặp qua từng ký tự trong chuỗi văn bản
  for (let i = 0; i < text.length; i++) {
    const keyChar = key[i % key.length]; // Lặp qua khóa nếu khóa ngắn hơn văn bản
    encryptedText += String.fromCharCode(
      text.charCodeAt(i) ^ keyChar.charCodeAt(0),
    ); // XOR và chuyển lại thành ký tự
  }
  return encryptedText;
}

// Helper function to calculate time difference
export function formatTimeAgo(date: string) {
  const now = new Date();
  const createdAt = new Date(date);
  const diffInSeconds = Math.floor(
    (now.getTime() - createdAt.getTime()) / 1000,
  );

  const diffInMinutes = Math.floor(diffInSeconds / 60);
  const diffInHours = Math.floor(diffInMinutes / 60);
  const diffInDays = Math.floor(diffInHours / 24);

  if (diffInMinutes < 1) {
    return `${diffInSeconds} seconds ago`;
  }
  if (diffInMinutes < 60) {
    return `${diffInMinutes} minutes ago`;
  }
  if (diffInHours < 24) {
    return `${diffInHours} hours ago`;
  }
  return `${diffInDays} days ago`;
}
